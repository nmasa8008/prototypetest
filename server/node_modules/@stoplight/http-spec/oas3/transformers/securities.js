"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformToSingleSecurity = exports.translateToSecurities = void 0;
const utils_1 = require("../../utils");
const accessors_1 = require("../accessors");
const guards_1 = require("../guards");
function translateToSecurities(document, operationSecurities) {
    const securities = accessors_1.getSecurities(document, operationSecurities);
    return securities.map(security => security.reduce((transformedSecurities, sec) => {
        const transformed = transformToSingleSecurity(sec, sec.key);
        if (transformed) {
            transformedSecurities.push(transformed);
        }
        return transformedSecurities;
    }, []));
}
exports.translateToSecurities = translateToSecurities;
function transformToSingleSecurity(securityScheme, key) {
    var _a, _b;
    const baseObject = {
        key,
    };
    if (securityScheme.description) {
        baseObject.description = securityScheme.description;
    }
    if (securityScheme.type === 'apiKey') {
        return Object.assign(Object.assign({}, baseObject), { type: 'apiKey', name: securityScheme.name, in: securityScheme.in });
    }
    if (securityScheme.type === 'http') {
        if (((_a = securityScheme.scheme) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'bearer') {
            return Object.assign(Object.assign({}, baseObject), { type: 'http', scheme: 'bearer', bearerFormat: securityScheme.bearerFormat });
        }
        return Object.assign(Object.assign({}, baseObject), { type: 'http', scheme: (_b = securityScheme.scheme) === null || _b === void 0 ? void 0 : _b.toLowerCase() });
    }
    if (securityScheme.type === 'oauth2') {
        return Object.assign(Object.assign({}, baseObject), { type: 'oauth2', flows: transformFlows(securityScheme.flows) });
    }
    if (securityScheme.type === 'openIdConnect') {
        return Object.assign(Object.assign({}, baseObject), { type: 'openIdConnect', openIdConnectUrl: securityScheme.openIdConnectUrl });
    }
    return undefined;
}
exports.transformToSingleSecurity = transformToSingleSecurity;
function transformFlows(flows) {
    const transformedFlows = {};
    if (!utils_1.isDictionary(flows)) {
        return transformedFlows;
    }
    if (guards_1.isOAuthFlowObject(flows.password) && typeof flows.password.tokenUrl === 'string') {
        transformedFlows.password = Object.assign(Object.assign({}, (typeof flows.password.refreshUrl === 'string' && { refreshUrl: flows.password.refreshUrl })), { tokenUrl: flows.password.tokenUrl, scopes: flows.password.scopes });
    }
    if (guards_1.isOAuthFlowObject(flows.implicit) && typeof flows.implicit.authorizationUrl === 'string') {
        transformedFlows.implicit = Object.assign(Object.assign({}, (typeof flows.implicit.refreshUrl === 'string' && { refreshUrl: flows.implicit.refreshUrl })), { authorizationUrl: flows.implicit.authorizationUrl, scopes: flows.implicit.scopes });
    }
    if (guards_1.isOAuthFlowObject(flows.authorizationCode) &&
        typeof flows.authorizationCode.authorizationUrl === 'string' &&
        typeof flows.authorizationCode.tokenUrl === 'string') {
        transformedFlows.authorizationCode = Object.assign(Object.assign({}, (typeof flows.authorizationCode.refreshUrl === 'string' && { refreshUrl: flows.authorizationCode.refreshUrl })), { authorizationUrl: flows.authorizationCode.authorizationUrl, scopes: flows.authorizationCode.scopes, tokenUrl: flows.authorizationCode.tokenUrl });
    }
    if (guards_1.isOAuthFlowObject(flows.clientCredentials) && typeof flows.clientCredentials.tokenUrl === 'string') {
        transformedFlows.clientCredentials = Object.assign(Object.assign({}, (typeof flows.clientCredentials.refreshUrl === 'string' && { refreshUrl: flows.clientCredentials.refreshUrl })), { scopes: flows.clientCredentials.scopes, tokenUrl: flows.clientCredentials.tokenUrl });
    }
    return transformedFlows;
}
//# sourceMappingURL=securities.js.map