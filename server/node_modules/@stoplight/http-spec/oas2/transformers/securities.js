"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateToSecurities = exports.translateToSingleSecurity = void 0;
const lodash_1 = require("lodash");
const utils_1 = require("../../utils");
const accessors_1 = require("../accessors");
const guards_1 = require("../guards");
function translateToFlows(security) {
    const flows = {};
    const scopes = utils_1.isDictionary(security.scopes) ? lodash_1.pickBy(security.scopes, lodash_1.isString) : {};
    const authorizationUrl = 'authorizationUrl' in security && typeof security.authorizationUrl === 'string' ? security.authorizationUrl : '';
    const tokenUrl = 'tokenUrl' in security && typeof security.tokenUrl === 'string' ? security.tokenUrl : '';
    if (security.flow === 'implicit') {
        flows.implicit = {
            authorizationUrl,
            scopes,
        };
    }
    else if (security.flow === 'password') {
        flows.password = {
            tokenUrl,
            scopes,
        };
    }
    else if (security.flow === 'application') {
        flows.clientCredentials = {
            tokenUrl,
            scopes,
        };
    }
    else if (security.flow === 'accessCode') {
        flows.authorizationCode = {
            authorizationUrl,
            tokenUrl,
            scopes,
        };
    }
    return flows;
}
function translateToBasicSecurityScheme(security, key) {
    return {
        type: 'http',
        scheme: 'basic',
        description: security.description,
        key,
    };
}
function translateToApiKeySecurityScheme(security, key) {
    const acceptableSecurityOrigins = ['query', 'header'];
    if ('in' in security && security.in && acceptableSecurityOrigins.includes(security.in)) {
        return {
            type: 'apiKey',
            name: security.name || '',
            in: security.in,
            description: security.description,
            key,
        };
    }
    return undefined;
}
const VALID_OAUTH2_FLOWS = ['implicit', 'password', 'application', 'accessCode'];
function translateToOauth2SecurityScheme(security, key) {
    if (!security.flow || !VALID_OAUTH2_FLOWS.includes(security.flow))
        return undefined;
    return {
        type: 'oauth2',
        flows: translateToFlows(security),
        description: security.description,
        key,
    };
}
function translateToSingleSecurity(security, key) {
    if (guards_1.isSecurityScheme(security)) {
        switch (security.type) {
            case 'basic':
                return translateToBasicSecurityScheme(security, key);
            case 'apiKey':
                return translateToApiKeySecurityScheme(security, key);
            case 'oauth2':
                return translateToOauth2SecurityScheme(security, key);
        }
    }
    return;
}
exports.translateToSingleSecurity = translateToSingleSecurity;
function translateToSecurities(document, operationSecurity) {
    const securities = accessors_1.getSecurities(document, operationSecurity);
    return securities.map(security => security.reduce((transformedSecurities, sec) => {
        const transformed = translateToSingleSecurity(sec, sec.key);
        if (transformed) {
            transformedSecurities.push(transformed);
        }
        return transformedSecurities;
    }, []));
}
exports.translateToSecurities = translateToSecurities;
//# sourceMappingURL=securities.js.map