"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAgainstSchema = exports.convertAjvErrors = void 0;
const types_1 = require("@stoplight/types");
const O = require("fp-ts/Option");
const pipeable_1 = require("fp-ts/pipeable");
const NonEmptyArray_1 = require("fp-ts/NonEmptyArray");
const AjvOAI = require("ajv-oai");
const ajv = new AjvOAI({ allErrors: true, messages: true, schemaId: 'auto' });
const ajvNoCoerce = new AjvOAI({ allErrors: true, messages: true, schemaId: 'auto', coerceTypes: false });
const convertAjvErrors = (errors, severity, prefix) => pipeable_1.pipe(errors, NonEmptyArray_1.map(error => {
    const allowedParameters = 'allowedValues' in error.params ? `: ${error.params.allowedValues.join(', ')}` : '';
    const detectedAdditionalProperties = 'additionalProperty' in error.params ? `; found '${error.params.additionalProperty}'` : '';
    const errorPath = error.dataPath.split('.').filter(segment => segment !== '');
    const path = prefix ? [prefix, ...errorPath] : errorPath;
    return {
        path,
        code: error.keyword || '',
        message: `${error.message || ''}${allowedParameters}${detectedAdditionalProperties}`,
        severity,
    };
}));
exports.convertAjvErrors = convertAjvErrors;
const validateAgainstSchema = (value, schema, coerce, prefix) => pipeable_1.pipe(O.tryCatch(() => (coerce ? ajv : ajvNoCoerce).compile(schema)), O.chainFirst(validateFn => O.tryCatch(() => validateFn(value))), O.chain(validateFn => pipeable_1.pipe(O.fromNullable(validateFn.errors), O.chain(NonEmptyArray_1.fromArray))), O.map(errors => exports.convertAjvErrors(errors, types_1.DiagnosticSeverity.Error, prefix)));
exports.validateAgainstSchema = validateAgainstSchema;
