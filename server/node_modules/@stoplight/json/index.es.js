import{isObject as e,cloneDeep as r,get as n,has as t,set as o,trimStart as i}from"lodash";import{createScanner as s,findNodeAtOffset as a,getNodePath as c,visit as f,printParseErrorCode as u}from"jsonc-parser";import l,{getOrder as p,ORDER_KEY_ID as h}from"@stoplight/ordered-object-literal";import{DiagnosticSeverity as g}from"@stoplight/types";import y from"safe-stable-stringify";const d=r=>e(r)&&"$ref"in r&&"string"==typeof r.$ref,b=e=>e.length>0&&"#"===e[0],m=(e,r,n)=>{const t=e.toString();let o="",i=t,s=0,a=i.indexOf(r);for(;a>-1;)o+=t.substring(s,s+a)+n,i=i.substring(a+r.length,i.length),s+=a+r.length,a=i.indexOf(r);return i.length>0&&(o+=t.substring(t.length-i.length,t.length)),o},w=e=>"number"==typeof e?e:m(m(e,"~","~0"),"/","~1"),v=e=>_(e),_=e=>{if(e&&"object"!=typeof e)throw new TypeError("Invalid type: path must be an array of segments.");return 0===e.length?"#":`#/${e.map(w).join("/")}`},O=e=>m(m(decodeURIComponent(""+e),"~1","/"),"~0","~"),x=e=>A(e),A=e=>{if("string"!=typeof e)throw new TypeError("Invalid type: JSON Pointers are represented as strings.");if(0===e.length||"#"!==e[0])throw new URIError("Invalid JSON Pointer syntax; URI fragment identifiers must begin with a hash.");if(1===e.length)return[];if("/"!==e[1])throw new URIError("Invalid JSON Pointer syntax.");return(e=>{const r=e.length,n=[];let t=-1;for(;++t<r;)n.push(O(e[t]));return n})(e.substring(2).split("/"))},j=(e,r,n=[])=>{if(e&&"object"==typeof e)for(const t in e)e.hasOwnProperty(t)&&(r({parent:e,parentPath:n,property:t,propertyValue:e[t]}),e[t]&&"object"==typeof e[t]&&j(e[t],r,n.concat(t)))},E="__bundled__",N="__errors__",S=({document:e,path:n},t)=>$(r(e),n,{[n]:!0},t),$=(e,r,i,s,a={},c={},f={})=>{const u=n(e,x(r));return j(s||u,({parent:s})=>{if(d(s)&&b(s.$ref)){const u=s.$ref;if(f[u])return;if(a[u])return void(s.$ref=a[u]);let l,p,h;try{l=x(u),p=["__bundled__",...l],h=v(p)}catch(e){f[u]=e.message}if(!l||!p||!h)return;const g=n(e,l);if(void 0!==g){const y=[];a[u]=h,s.$ref=h;for(const r of l){y.push(r);const i=["__bundled__",...y];if(t(c,i))continue;const s=n(e,y);Array.isArray(s)?o(c,i,new Array(s.length).fill(null)):"object"==typeof s&&o(c,i,{})}o(c,p,g),i[u]||(i[u]=!0,$(e,r,i,g,a,c,f),i[u]=!1)}}}),o(u,"__bundled__",c.__bundled__),Object.keys(f).length&&o(u,"__errors__",f),u},T=e=>m(m(e,"~1","/"),"~0","~"),k=e=>m(m(e,"~","~0"),"//","/~1"),I=e=>{if("string"!=typeof e||0===e.length)return null;const r=e.indexOf("#");return-1===r?null:e.slice(r)},P=e=>{if("string"!=typeof e||0===e.length||b(e))return null;const r=e.indexOf("#");return-1===r?e:e.slice(0,r)},K=e=>{const r=s(e,!0);if(r.scan(),1!==r.getToken())return;if(r.scan(),2===r.getToken())return;if(10!==r.getToken())throw new SyntaxError("Unexpected character");const n=r.getTokenValue();if(r.scan(),6!==r.getToken())throw new SyntaxError("Colon expected");switch(r.scan(),r.getToken()){case 10:return[n,r.getTokenValue()];case 11:return[n,Number(r.getTokenValue())];case 8:return[n,!0];case 9:return[n,!1];case 7:return[n,null];case 16:throw new SyntaxError("Unexpected character");case 17:throw new SyntaxError("Unexpected end of file");default:return}},M=({lineMap:e,ast:r},n)=>{const t=e[n.line],o=e[n.line+1];if(void 0===t)return;const i=a(r,void 0===o?t+n.character:Math.min(o,t+n.character),!0);if(void 0===i)return;const s=c(i);return 0!==s.length?s:void 0};function R(e){return T(e.split("/").pop()||"")}const U=({lineMap:e,ast:r},n,t=!1)=>{const o=function(e,r,n){e:for(const t of r){const r=Number.isInteger(Number(t))?Number(t):t;if("string"==typeof r||"number"==typeof r&&"array"!==e.type){if("object"!==e.type||!Array.isArray(e.children))return n?e:void 0;for(const n of e.children)if(Array.isArray(n.children)&&n.children[0].value===String(r)){e=n.children[1];continue e}return n?e:void 0}if("array"!==e.type||r<0||!Array.isArray(e.children)||r>=e.children.length)return n?e:void 0;e=e.children[r]}return e}(r,n,t);if(void 0!==o&&void 0!==o.range)return{range:o.range}};const C=(e,r={disallowComments:!0})=>{const n=[],{ast:t,data:o,lineMap:i}=J(e,n,r);return{data:o,diagnostics:n,ast:t,lineMap:i}};function J(e,r=[],n){const t=D(e);let o={type:"array",offset:-1,length:-1,children:[],parent:void 0},i=null,s=[];const a=new WeakMap,c=[];function h(e){"property"===o.type&&(o.length=e-o.offset,o=o.parent)}function y(e,r,n){return{start:{line:e,character:r},end:{line:e,character:r+n}}}function d(e){return o.children.push(e),e}function b(e){Array.isArray(s)?s.push(e):null!==i&&(s[i]=e)}function m(e){b(e),c.push(s),s=e,i=null}function w(){s=c.pop()}f(e,{onObjectBegin:(e,r,t,i)=>{o=d({type:"object",offset:e,length:-1,parent:o,children:[],range:y(t,i,r)}),!1===n.ignoreDuplicateKeys&&a.set(o,[]),m(function(e){return e?l({}):{}}(!0===n.preserveKeyOrder))},onObjectProperty:(e,t,c,f,u)=>{if((o=d({type:"property",offset:t,length:-1,parent:o,children:[]})).children.push({type:"string",value:e,offset:t,length:c,parent:o}),!1===n.ignoreDuplicateKeys){const n=a.get(o.parent);n&&(0!==n.length&&n.includes(e)?r.push({range:y(f,u,c),message:"DuplicateKey",severity:g.Error,path:B(o),code:20}):n.push(e))}!0===n.preserveKeyOrder&&function(e,r){if(!(r in e))return;const n=p(e),t=n.indexOf(r);-1!==t&&(n.splice(t,1),n.push(r))}(s,e),i=e},onObjectEnd:(e,r,t,i)=>{!1===n.ignoreDuplicateKeys&&a.delete(o),o.length=e+r-o.offset,o.range&&(o.range.end.line=t,o.range.end.character=i+r),o=o.parent,h(e+r),w()},onArrayBegin:(e,r,n,t)=>{o=d({type:"array",offset:e,length:-1,parent:o,children:[],range:y(n,t,r)}),m([])},onArrayEnd:(e,r,n,t)=>{o.length=e+r-o.offset,o.range&&(o.range.end.line=n,o.range.end.character=t+r),o=o.parent,h(e+r),w()},onLiteralValue:(e,r,n,t,i)=>{d({type:V(e),offset:r,length:n,parent:o,value:e,range:y(t,i,n)}),h(r+n),b(e)},onSeparator:(e,r,n)=>{"property"===o.type&&(":"===e?o.colonOffset=r:","===e&&h(r))},onError:(e,n,t,o,i)=>{r.push({range:y(o,i,t),message:u(e),severity:g.Error,code:e})}},n);const v=o.children[0];return v&&delete v.parent,{ast:v,data:s[0],lineMap:t}}function V(e){switch(typeof e){case"boolean":return"boolean";case"number":return"number";case"string":return"string";default:return"null"}}const D=e=>{const r=[0];let n=0;for(;n<e.length;n++)"\n"===e[n]&&r.push(n+1);return r.push(n+1),r};function B(e,r=[]){return"property"===e.type&&r.unshift(e.children[0].value),void 0!==e.parent?("array"===e.parent.type&&void 0!==e.parent.parent&&r.unshift(e.parent.children.indexOf(e)),B(e.parent,r)):r}const W=(e,r,n)=>{if(!e||!Object.hasOwnProperty.call(e,r)||r===n)return e;const t={};for(const[o,i]of Object.entries(e))o===r?t[n]=i:o in t||(t[o]=i);return t};function F(e){return"object"==typeof e&&null!==e}function L(e,r){return function e(r,n,t){if(null!==P(n))throw new ReferenceError("Cannot resolve external references");const o=x(n);let i=r;for(const s of o){if(!(F(i)&&s in i))throw new ReferenceError(`Could not resolve '${n}'`);if(F(i=i[s])&&"$ref"in i){if(t.includes(i))return t[t.length-1];if(t.push(i),"string"!=typeof i.$ref)throw new TypeError("$ref should be a string");i=e(r,i.$ref,t)}}return i}(e,r,[])}const q=(e,r)=>{if("string"!=typeof e)return e;try{const n=z(e);return"string"==typeof n?n:JSON.parse(e,r)}catch(e){return}},z=e=>{const r=Number(e);return Number.isFinite(r)?String(r)===e?r:e:NaN},G=(e,r,n)=>{if("string"==typeof e)return e;try{return JSON.stringify(e,r,n)}catch(t){return y(e,r,n)}},H=(e,r)=>{if(e instanceof Array){if(r instanceof Array){if(r.length>e.length)return!1;for(const n in r){if(!r.hasOwnProperty(n))continue;const t=parseInt(e[n]),o=parseInt(r[n]);if(isNaN(t)&&isNaN(o)){if(e[n]!==r[n])return!1}else if(t!==o)return!1}}}else{if("string"!=typeof e)return!1;if("string"==typeof r)return e.startsWith(r)}return!0},Q=(e,r,n)=>{const t=G(e,r,n);if(void 0===t)throw new Error("The value could not be stringified");return t};function X(e){return e.replace(/^(\/|#\/)/,"").split("/").map(T).map(Y).join(".")}function Y(e){return e.includes(".")?`["${e.replace(/"/g,'\\"')}"]`:e}const Z=Symbol.for(h),ee={ownKeys:e=>Z in e?e[Z]:Reflect.ownKeys(e)},re=e=>new Proxy(e,ee);function ne(e,r){if("string"==typeof e&&"string"==typeof r)return i(e,r);if(!(e&&Array.isArray(e)&&e.length&&r&&Array.isArray(r)&&r.length))return e;let n=0;for(const t in e)if(e.hasOwnProperty(t)){if(e[t]!==r[t])break;n++}return e.slice(n)}export{E as BUNDLE_ROOT,N as ERRORS_ROOT,Z as KEYS,S as bundleTarget,O as decodePointer,T as decodePointerFragment,k as encodePointer,w as encodePointerFragment,I as extractPointerFromRef,P as extractSourceFromRef,K as getFirstPrimitiveProperty,M as getJsonPathForPosition,R as getLastPathSegment,U as getLocationForJsonPath,d as hasRef,b as isLocalRef,J as parseTree,C as parseWithPointers,v as pathToPointer,x as pointerToPath,W as renameObjectKey,L as resolveInlineRef,q as safeParse,G as safeStringify,H as startsWith,Q as stringify,X as toPropertyPath,re as trapAccess,j as traverse,ne as trimStart};
